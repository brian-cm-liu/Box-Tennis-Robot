#include <NewPing.h>

//Pins
const int sonarTrig = 11;
const int sonarEcho = 12;
const int MOTOR1_FORWARD = 9;
const int MOTOR1_BACKWARD = 8;
const int MOTOR1_ENABLE = 10;
const int MOTOR2_FORWARD = 6;
const int MOTOR2_BACKWARD = 7;
const int MOTOR2_ENABLE = 5;
const int IR_PIN = A0;
//const int left_servo =;
//const int right_servo =; 
//const int up_servo = ;

//States
/**
 *1. setting left
 *2. scanning right until block
 *3. forward until block
 *4. lower/close claw
 *5. return back
 *6. forward and open/launch claw
 *7. backwards to start
 *loop
 */
int state = 1;


//Creating sonar object and storing distance data
NewPing sonarSensor(sonarTrig, sonarEcho, 200);
int distanceToObject = 0;

//Movement Motor 1 is right side, Motor 2 is left side
//MotorL speed = MotorR speed * 1.4
const int forwardSpeedL = 212;
const int forwardSpeedR = 150;

//Variables for controlling how fast and precisely the robot turns
const int turnSpeedL = 212;
const int turnSpeedR = 150;
static float angle = 90; //0 is facing left, 180 is facing right
const float angleChangeRate = 0.25; //How quickly the variable changes, needs to be calibrated to match how quickly the robot turns
const float forwardChangeRate = 1;

//Variables for searching
const float searchDistance = 30;

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  Serial.println("Start");
  delay(1000);
  Serial.println("3");
  delay(1000);
  Serial.println("2");
  delay(1000);
  Serial.println("1");
  delay(1000);
  pinMode(IR_PIN, OUTPUT);
  //left_servo.attach(left_servo)
  //right_servo.attach(right_servo)
  //up_servo.attach(up_servo)
  //left_servo.write(0)
  //right_servo.write(0)
  //up_servo.write(0)
  //test();
}

void loop() {
  distanceToObject = sonarSensor.ping_cm(); 
  if(state == 1)
  {
    turn(0.0);
    if(angle<1){
      //delay(1000);
      state = 2;
    }
  }
  if(state == 2)
  {

  }
  if(state == 3)
  {
    
  }
  if(state == 4)
  {
    
  }
  if(state == 0)
  {
    
  }
}

void forward(){
  digitalWrite(MOTOR1_FORWARD,HIGH);
  digitalWrite(MOTOR1_BACKWARD,LOW);
  digitalWrite(MOTOR2_FORWARD,HIGH);
  digitalWrite(MOTOR2_BACKWARD,LOW);
  analogWrite(MOTOR1_ENABLE,forwardSpeedR);
  analogWrite(MOTOR2_ENABLE,forwardSpeedL);
}

/*
 * void forward(float dist){
  while (dist > 1) { 
    digitalWrite(MOTOR1_FORWARD,HIGH);
    digitalWrite(MOTOR1_BACKWARD,LOW);
    digitalWrite(MOTOR2_FORWARD,HIGH);
    digitalWrite(MOTOR2_BACKWARD,LOW);
    analogWrite(MOTOR1_ENABLE,speedR);
    analogWrite(MOTOR2_ENABLE,speedL);
    x += forwardChangeRate* sin(angle);
    y += forwardChangeRate *cos(angle);
    dist -= forwardChangeRate;
  }
  while (dist < 1) { 
    digitalWrite(MOTOR1_FORWARD,LOW);
    digitalWrite(MOTOR1_BACKWARD,HIGH);
    digitalWrite(MOTOR2_FORWARD,LOW);
    digitalWrite(MOTOR2_BACKWARD,HIGH);
    analogWrite(MOTOR1_ENABLE,speedR);
    analogWrite(MOTOR2_ENABLE,speedL);
    x -= forwardChangeRate * sin(angle);
    y -= forwardChangeRate *cos(angle);
    dist += forwardChangeRate;
  }
}
 * 
 */

//This function turns the robot to the specified global angle, 0 is facing left and 180 is facing right. The robot will face 90, forward, by default
void turn(float targetAngle){
  float angleDifference = targetAngle - angle;
  //Since we're dealing with floats, if the difference between the two is less than one, the robot stops turning
  if(angleDifference>1){
    angle += angleChangeRate;
    digitalWrite(MOTOR1_FORWARD,LOW);
    digitalWrite(MOTOR1_BACKWARD,HIGH);
    digitalWrite(MOTOR2_FORWARD,HIGH);
    digitalWrite(MOTOR2_BACKWARD,LOW);
    analogWrite(MOTOR1_ENABLE,turnSpeedR);
    analogWrite(MOTOR2_ENABLE,turnSpeedL);
    angleDifference = targetAngle - angle;
    return;
  }
  if(angleDifference<-1){
    angle -= angleChangeRate;
    digitalWrite(MOTOR1_FORWARD,HIGH);
    digitalWrite(MOTOR1_BACKWARD,LOW);
    digitalWrite(MOTOR2_FORWARD,LOW);
    digitalWrite(MOTOR2_BACKWARD,HIGH);
    analogWrite(MOTOR1_ENABLE,turnSpeedR);
    analogWrite(MOTOR2_ENABLE,turnSpeedL);
    angleDifference = targetAngle - angle;
    return;
  }
  else{
    pause();
  }
}
void pause(){
  digitalWrite(MOTOR1_FORWARD,LOW);
  digitalWrite(MOTOR1_BACKWARD,LOW);
  digitalWrite(MOTOR2_FORWARD,LOW);
  digitalWrite(MOTOR2_BACKWARD,LOW);
  delay(3000);
}

/*
void pickup(){
 // up_servo.write(180);
  //delay (1000);
  //left_servo.write(180);
  //right_servo.write(180) ;
  //up_servo.write(0) ;
}

void drop(){
  //up_servo.write();
  //left_servo.write();
  //right_servo.write();
}

void test(){
  forward(10);
  turn(90);
  forward(-10);
  turn(180);
}
 // turn(0)
  //while distanceToObject > 30{
    // turn(angle+5);
     //delay(1000);
  //forward(distanceToObject - //experimental distancee
  //pickup();
  //turn(0);
  //forward(middleY - y);
  //turn(90);
  //forward(//barrier x);
  //drop();
  //forward(-91.4);
*/
