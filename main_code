#include <NewPing.h>

//Pins
const int sonarTrig = 11;
const int sonarEcho = 12;
const int MOTOR1_FORWARD = 9;
const int MOTOR1_BACKWARD = 8;
const int MOTOR1_ENABLE = 10;
const int MOTOR2_FORWARD = 6;
const int MOTOR2_BACKWARD = 7;
const int MOTOR2_ENABLE = 5;
const int IR_PIN_R = A0;
const int IR_PIN_L = A1;

const int SERVO_1 = 3;
//const int left_servo =;
//const int right_servo =; 
//const int up_servo = ;

static int stage = 1;

//ir 20 white 1020 black
int IR_R_value = 0;
int IR_L_value = 0;


//Creating sonar object and storing distance data
NewPing sonarSensor(sonarTrig, sonarEcho, 200);
int distanceToObject = 0;

//Movement Motor 1 is right side, Motor 2 is left side
//MotorL speed = MotorR speed * 1.4
const int forwardSpeedL = 200;
const int forwardSpeedR = 142;

//Variables for controlling how fast and precisely the robot turns
const int turnSpeedL = 200;
const int turnSpeedR = 142;
static float angle = 90; //0 is facing left, 180 is facing right
const float angleChangeRate = 0.85; //How quickly the variable changes, needs to be calibrated to match how quickly the robot turns
const float forwardChangeRate = 1;

//Variables for searching
const float searchDistance = 50;
const float pickupDistance = 5;

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  pinMode(IR_PIN_R,INPUT);
  pinMode(IR_PIN_L,INPUT);
  delay(1000);
  //left_servo.attach(left_servo)
  //right_servo.attach(right_servo)
  //up_servo.attach(up_servo)
  //left_servo.write(0)
  //right_servo.write(0)
  //up_servo.write(0)
  //test();
}

void loop() {
  distanceToObject = sonarSensor.ping_cm();
  //Serial.println(distanceToObject);
  int irRight = analogRead(IR_PIN_R);
  int irLeft = analogRead(IR_PIN_L);
  /*
  if(stage == 0)
  {
    //move servo down
  }
  */
  if(stage == 1)
  {
    turn(-1);
    if(irLeft>500)
    {
      Serial.println("Line detected");
      stage = 2;
      halt();
    }
  }
  if(stage == 2)
  {
    turn(1);
    if(distanceToObject<searchDistance && distanceToObject != 0)
    {
      Serial.println("Object found");
      delay(20);
      stage = 3;
      halt();
    }
    if(irRight>500)
    {
      Serial.println("Line detected");
      stage = 1;
      halt();
    }
  }
  if(stage == 3)
  {
    Serial.println(distanceToObject);
    if(distanceToObject>5)
    {
      forward();
    }
    else{
      stage == 4;
    }
  }
  if(stage == 4)
  {
    Serial.println("Stage 4");
    halt();
  }
}
//Move forward an arbitrary distance
void forward(){
  digitalWrite(MOTOR1_FORWARD,HIGH);
  digitalWrite(MOTOR1_BACKWARD,LOW);
  digitalWrite(MOTOR2_FORWARD,HIGH);
  digitalWrite(MOTOR2_BACKWARD,LOW);
  analogWrite(MOTOR1_ENABLE,forwardSpeedR);
  analogWrite(MOTOR2_ENABLE,forwardSpeedL);
}

/* //Move forward or backward a defined distance
 * void move(float dist){
  while (dist > 1) { 
    digitalWrite(MOTOR1_FORWARD,HIGH);
    digitalWrite(MOTOR1_BACKWARD,LOW);
    digitalWrite(MOTOR2_FORWARD,HIGH);
    digitalWrite(MOTOR2_BACKWARD,LOW);
    analogWrite(MOTOR1_ENABLE,speedR);
    analogWrite(MOTOR2_ENABLE,speedL);
    x += forwardChangeRate* sin(angle);
    y += forwardChangeRate *cos(angle);
    dist -= forwardChangeRate;
  }
  while (dist < 1) { 
    digitalWrite(MOTOR1_FORWARD,LOW);
    digitalWrite(MOTOR1_BACKWARD,HIGH);
    digitalWrite(MOTOR2_FORWARD,LOW);
    digitalWrite(MOTOR2_BACKWARD,HIGH);
    analogWrite(MOTOR1_ENABLE,speedR);
    analogWrite(MOTOR2_ENABLE,speedL);
    x -= forwardChangeRate * sin(angle);
    y -= forwardChangeRate *cos(angle);
    dist += forwardChangeRate;
  }
}
 * 
 */

//This function turns the robot to the specified global angle, 0 is facing left and 180 is facing right. The robot will face 90, forward, by default
void turn(float targetAngle){
  //float angleDifference = targetAngle - angle;
  //Since we're dealing with floats, if the difference between the two is less than one, the robot stops turning
  if(targetAngle == 1){
    angle += angleChangeRate;
    digitalWrite(MOTOR1_FORWARD,LOW);
    digitalWrite(MOTOR1_BACKWARD,HIGH);
    digitalWrite(MOTOR2_FORWARD,HIGH);
    digitalWrite(MOTOR2_BACKWARD,LOW);
    analogWrite(MOTOR1_ENABLE,turnSpeedR);
    analogWrite(MOTOR2_ENABLE,turnSpeedL);
    return;
  }
  if(targetAngle == -1){
    angle -= angleChangeRate;
    digitalWrite(MOTOR1_FORWARD,HIGH);
    digitalWrite(MOTOR1_BACKWARD,LOW);
    digitalWrite(MOTOR2_FORWARD,LOW);
    digitalWrite(MOTOR2_BACKWARD,HIGH);
    analogWrite(MOTOR1_ENABLE,turnSpeedR);
    analogWrite(MOTOR2_ENABLE,turnSpeedL);
    return;
  }
  else{
    halt();
  }
}
void halt(){
  digitalWrite(MOTOR1_FORWARD,LOW);
  digitalWrite(MOTOR1_BACKWARD,LOW);
  digitalWrite(MOTOR2_FORWARD,LOW);
  digitalWrite(MOTOR2_BACKWARD,LOW);
  analogWrite(MOTOR1_ENABLE,0);
  analogWrite(MOTOR2_ENABLE,0);
  delay(500);
}

/*
void pickup(){
 // up_servo.write(180);
  //delay (1000);
  //left_servo.write(180);
  //right_servo.write(180) ;
  //up_servo.write(0) ;
}

void drop(){
  //up_servo.write();
  //left_servo.write();
  //right_servo.write();
}

void test(){
  forward(10);
  turn(90);
  forward(-10);
  turn(180);
}
 // turn(0)
  //while distanceToObject > 30{
    // turn(angle+5);
     //delay(1000);
  //forward(distanceToObject - //experimental distancee
  //pickup();
  //turn(0);
  //forward(middleY - y);
  //turn(90);
  //forward(//barrier x);
  //drop();
  //forward(-91.4);
*/
